#!/usr/bin/env bash
set -euo pipefail

KIT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
MANIFEST_FILENAME=".opencode-kit.json"

module_version_from_file() {
  local path="$1"

  python3 - "$path" <<'PY'
import re
import sys

path = sys.argv[1]

with open(path, "r", encoding="utf-8") as f:
  text = f.read()

if not text.startswith("---"):
  print("")
  sys.exit(0)

m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
if not m:
  print("")
  sys.exit(0)

frontmatter = m.group(1).splitlines()
for line in frontmatter:
  if line.strip().startswith("version:"):
    value = line.split(":", 1)[1].strip().strip('"').strip("'")
    print(value)
    sys.exit(0)

print("")
PY
}

require_module_version() {
  local path="$1"
  local version

  version="$(module_version_from_file "$path")"
  [[ -n "$version" ]] || die "module is missing version frontmatter: $path"
  [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || die "invalid module version (use semver x.y.z): $version ($path)"

  printf '%s\n' "$version"
}

err() {
  printf 'error: %s\n' "$*" >&2
}

die() {
  err "$*"
  exit 1
}

project_root() {
  if git rev-parse --show-toplevel >/dev/null 2>&1; then
    git rev-parse --show-toplevel
  else
    pwd
  fi
}

ensure_manifest() {
  if [[ ! -f "$MANIFEST_FILENAME" ]]; then
    cat > "$MANIFEST_FILENAME" <<'JSON'
{
  "version": 1,
  "installed": {
    "rulesLazy": null,
    "rule": {},
    "skill": {},
    "agent": {}
  }
}
JSON
  fi
}

json_set() {
  # json_set <kind> <name> <source> <module_version> <path1> [path2 ...]
  local kind="$1"
  local name="$2"
  local source="$3"
  local module_version="$4"
  shift 4

  local paths_json
  paths_json="$(python3 - <<'PY' "$@"
import json,sys
print(json.dumps(sys.argv[1:]))
PY
)"

  python3 - "$MANIFEST_FILENAME" "$kind" "$name" "$source" "$module_version" "$paths_json" <<'PY'
import datetime
import json
import sys

manifest_path, kind, name, source, module_version, paths_json = sys.argv[1:]
paths = json.loads(paths_json)

def load():
  with open(manifest_path, "r", encoding="utf-8") as f:
    return json.load(f)

def dump(data):
  with open(manifest_path, "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2, ensure_ascii=False)
    f.write("\n")

data = load()
installed = data.setdefault("installed", {})

today = datetime.date.today().isoformat()

entry = {
  "source": source,
  "moduleVersion": module_version,
  "installedPaths": paths,
  "installedAt": today,
}

if kind == "rulesLazy":
  installed["rulesLazy"] = entry
else:
  bucket = installed.setdefault(kind, {})
  bucket[name] = entry

dump(data)
PY
}

validate_kebab() {
  local value="$1"
  [[ "$value" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]] || die "invalid name (use kebab-case): $value"
}

cmd_list() {
  local kind="${1:-}"
  case "$kind" in
    skills)
      (cd "$KIT_ROOT" && ls -1 "modules/skill" 2>/dev/null || true)
      ;;
    agents)
      (cd "$KIT_ROOT" && ls -1 "modules/agent" 2>/dev/null | sed 's/\.md$//' || true)
      ;;
    rules)
      # Print <group>/<doc> for rule modules that contain both loader.md and rule.md
      (cd "$KIT_ROOT" && \
        find "modules/rules" -mindepth 2 -maxdepth 3 -type f -name "loader.md" 2>/dev/null | while read -r loader; do
          base_dir="${loader%/loader.md}"
          if [[ -f "$base_dir/rule.md" ]]; then
            rel="${base_dir#modules/rules/}"
            printf '%s\n' "$rel"
          fi
        done | sort -u
      )
      ;;
    *)
      die "usage: opencode-kit list {skills|agents|rules}"
      ;;
  esac
}

add_rules_lazy() {
  local src="$KIT_ROOT/modules/rules/_lazy.md"
  [[ -f "$src" ]] || die "kit is missing modules/rules/_lazy.md"

  local dst_dir=".opencode/rules"
  local dst="$dst_dir/_lazy.md"

  if [[ -e "$dst" ]]; then
    die "rules lazy loader already exists: $dst"
  fi

  mkdir -p "$dst_dir"
  cp "$src" "$dst"

  local module_version
  module_version="$(require_module_version "$src")"

  ensure_manifest
  json_set "rulesLazy" "rulesLazy" "modules/rules/_lazy.md" "$module_version" "$dst"

  printf 'installed rules lazy loader: %s\n' "$dst"
  printf '\n'
  printf 'To enable lazy rules, add to opencode.json:\n'
  printf '  "instructions": [".opencode/rules/_lazy.md", ".opencode/rules/**/loader.md"]\n'
}

add_rule() {
  local id="${1:-}"
  [[ -n "$id" ]] || die "usage: opencode-kit add-rule <group>/<doc>"

  local group="${id%%/*}"
  local doc="${id#*/}"
  [[ "$group" != "$id" ]] || die "rule id must be <group>/<doc> (got: $id)"
  [[ -n "$doc" ]] || die "rule id must be <group>/<doc> (got: $id)"

  validate_kebab "$group"
  validate_kebab "$doc"

  local lazy_dst=".opencode/rules/_lazy.md"
  [[ -f "$lazy_dst" ]] || die "missing $lazy_dst (run: opencode-kit add-rules-lazy)"

  local src_dir="$KIT_ROOT/modules/rules/$group/$doc"
  [[ -d "$src_dir" ]] || die "rule module not found: $id ($src_dir)"
  [[ -f "$src_dir/loader.md" ]] || die "rule module is missing loader.md: $src_dir/loader.md"
  [[ -f "$src_dir/rule.md" ]] || die "rule module is missing rule.md: $src_dir/rule.md"

  local dst_dir=".opencode/rules/$group/$doc"
  if [[ -e "$dst_dir" ]]; then
    die "destination already exists: $dst_dir"
  fi

  mkdir -p "$dst_dir"
  cp "$src_dir/loader.md" "$dst_dir/loader.md"
  cp "$src_dir/rule.md" "$dst_dir/rule.md"

  local module_version
  module_version="$(require_module_version "$src_dir/loader.md")"

  ensure_manifest
  json_set "rule" "$id" "modules/rules/$group/$doc" "$module_version" "$dst_dir/loader.md" "$dst_dir/rule.md"

  printf 'installed rule: %s\n' "$id"
  printf '  %s\n' "$dst_dir/loader.md"
  printf '  %s\n' "$dst_dir/rule.md"
}

add_skill() {
  local name="${1:-}"
  [[ -n "$name" ]] || die "usage: opencode-kit add-skill <name>"
  validate_kebab "$name"

  local src="$KIT_ROOT/modules/skill/$name/SKILL.md"
  [[ -f "$src" ]] || die "skill module not found: $name ($src)"

  local dst_dir=".opencode/skill/$name"
  local dst="$dst_dir/SKILL.md"

  if [[ -e "$dst_dir" || -e "$dst" ]]; then
    die "destination already exists: $dst_dir"
  fi

  mkdir -p "$dst_dir"
  cp "$src" "$dst"

  local module_version
  module_version="$(require_module_version "$src")"

  ensure_manifest
  json_set "skill" "$name" "modules/skill/$name" "$module_version" "$dst"

  printf 'installed skill: %s -> %s\n' "$name" "$dst"
}

add_agent() {
  local name="${1:-}"
  [[ -n "$name" ]] || die "usage: opencode-kit add-agent <name>"
  validate_kebab "$name"

  local src="$KIT_ROOT/modules/agent/$name.md"
  [[ -f "$src" ]] || die "agent module not found: $name ($src)"

  local dst_dir=".opencode/agent"
  local dst="$dst_dir/$name.md"

  if [[ -e "$dst" ]]; then
    die "destination already exists: $dst"
  fi

  mkdir -p "$dst_dir"
  cp "$src" "$dst"

  local module_version
  module_version="$(require_module_version "$src")"

  ensure_manifest
  json_set "agent" "$name" "modules/agent/$name.md" "$module_version" "$dst"

  printf 'installed agent: %s -> %s\n' "$name" "$dst"
}

cmd_update() {
  ensure_manifest

  python3 - "$MANIFEST_FILENAME" "$KIT_ROOT" <<'PY'
import datetime
import json
import os
import re
import shutil
import sys

manifest_path, kit_root = sys.argv[1:]

today = datetime.date.today().isoformat()


def load_manifest():
  with open(manifest_path, "r", encoding="utf-8") as f:
    return json.load(f)


def dump_manifest(data):
  with open(manifest_path, "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2, ensure_ascii=False)
    f.write("\n")


def read_frontmatter_version(path):
  try:
    with open(path, "r", encoding="utf-8") as f:
      text = f.read()
  except FileNotFoundError:
    return ""

  if not text.startswith("---"):
    return ""

  m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
  if not m:
    return ""

  for line in m.group(1).splitlines():
    if line.strip().startswith("version:"):
      return line.split(":", 1)[1].strip().strip('"').strip("'")

  return ""


def parse_semver(value, *, allow_empty=False, context=""):
  value = (value or "").strip()
  if value == "" and allow_empty:
    return None

  m = re.match(r"^(\d+)\.(\d+)\.(\d+)$", value)
  if not m:
    raise ValueError(f"invalid semver x.y.z: {value} ({context})")

  return (int(m.group(1)), int(m.group(2)), int(m.group(3)))


def safe_dst_path(path):
  if os.path.isabs(path):
    raise ValueError(f"absolute path not allowed in manifest: {path}")

  normalized = os.path.normpath(path)
  if normalized == ".." or normalized.startswith(".." + os.sep):
    raise ValueError(f"parent traversal not allowed in manifest: {path}")

  if not (normalized == ".opencode" or normalized.startswith(".opencode" + os.sep)):
    raise ValueError(f"destination must stay under .opencode/: {path}")

  return normalized


def kit_paths_for_entry(kind, name, dst_paths):
  if kind == "rulesLazy":
    if len(dst_paths) != 1:
      raise ValueError(f"rulesLazy must have exactly 1 installed path (got {len(dst_paths)})")
    return {dst_paths[0]: os.path.join(kit_root, "modules/rules/_lazy.md")}

  if kind == "agent":
    if len(dst_paths) != 1:
      raise ValueError(f"agent must have exactly 1 installed path (got {len(dst_paths)})")
    return {dst_paths[0]: os.path.join(kit_root, f"modules/agent/{name}.md")}

  if kind == "skill":
    if len(dst_paths) != 1:
      raise ValueError(f"skill must have exactly 1 installed path (got {len(dst_paths)})")
    return {dst_paths[0]: os.path.join(kit_root, f"modules/skill/{name}/SKILL.md")}

  if kind == "rule":
    group, doc = name.split("/", 1)
    src_dir = os.path.join(kit_root, f"modules/rules/{group}/{doc}")
    mapping = {}
    for dst in dst_paths:
      base = os.path.basename(dst)
      if base == "loader.md":
        mapping[dst] = os.path.join(src_dir, "loader.md")
      elif base == "rule.md":
        mapping[dst] = os.path.join(src_dir, "rule.md")
      else:
        raise ValueError(f"unexpected rule installed path: {dst}")
    return mapping

  raise ValueError(f"unknown kind: {kind}")


def representative_kit_file(kind, name):
  if kind == "rulesLazy":
    return os.path.join(kit_root, "modules/rules/_lazy.md")
  if kind == "agent":
    return os.path.join(kit_root, f"modules/agent/{name}.md")
  if kind == "skill":
    return os.path.join(kit_root, f"modules/skill/{name}/SKILL.md")
  if kind == "rule":
    group, doc = name.split("/", 1)
    return os.path.join(kit_root, f"modules/rules/{group}/{doc}/loader.md")
  raise ValueError(f"unknown kind: {kind}")


def update_one(kind, name, entry):
  if not isinstance(entry, dict):
    return False

  dst_paths = entry.get("installedPaths") or []
  if not isinstance(dst_paths, list):
    raise ValueError(f"installedPaths must be a list ({kind} {name})")

  dst_paths = [safe_dst_path(p) for p in dst_paths]

  kit_file = representative_kit_file(kind, name)
  kit_version = read_frontmatter_version(kit_file)
  if kit_version == "":
    raise ValueError(f"kit module is missing version frontmatter: {kit_file}")
  kit_tuple = parse_semver(kit_version, context=kit_file)

  manifest_version = entry.get("moduleVersion", "")
  if manifest_version:
    installed_tuple = parse_semver(manifest_version, context=f"manifest {kind} {name}")
    installed_version = manifest_version
  else:
    detected = read_frontmatter_version(dst_paths[0]) if dst_paths else ""
    installed_tuple = parse_semver(detected, allow_empty=True, context=dst_paths[0] if dst_paths else "") or (0, 0, 0)
    installed_version = detected if detected else "0.0.0"

  should_update = kit_tuple > installed_tuple

  changed = False
  if should_update:
    mapping = kit_paths_for_entry(kind, name, dst_paths)
    for dst, src in mapping.items():
      if not os.path.exists(src):
        raise ValueError(f"kit source missing: {src}")
      os.makedirs(os.path.dirname(dst), exist_ok=True)
      shutil.copyfile(src, dst)

    entry["installedAt"] = today
    entry["moduleVersion"] = kit_version
    changed = True
    print(f"updated {kind} {name}: {installed_version} -> {kit_version}")
  else:
    if entry.get("moduleVersion") != installed_version and manifest_version == "":
      entry["moduleVersion"] = installed_version
      changed = True

    print(f"up-to-date {kind} {name}: {installed_version}")

  return changed


manifest = load_manifest()
installed = manifest.get("installed", {})

modified = False

rules_lazy = installed.get("rulesLazy")
if rules_lazy:
  modified = update_one("rulesLazy", "rulesLazy", rules_lazy) or modified

for kind in ["rule", "skill", "agent"]:
  bucket = installed.get(kind, {})
  if not isinstance(bucket, dict):
    raise ValueError(f"installed.{kind} must be an object")

  for name, entry in bucket.items():
    modified = update_one(kind, name, entry) or modified

if modified:
  dump_manifest(manifest)
PY
}

usage() {
  cat <<'HELP'
Usage:
  opencode-kit list skills|agents|rules
  opencode-kit add-rules-lazy
  opencode-kit add-rule <group>/<doc>
  opencode-kit add-skill <name>
  opencode-kit add-agent <name>
  opencode-kit update

Policy:
- Copy only (portable)
- Refuse overwrite: if destination exists, error (except: update)
- Does not edit AGENTS.md or opencode.json
- Writes manifest: .opencode-kit.json

Rule modules:
- Stored in kit: modules/rules/<group>/<doc>/{loader.md,rule.md}
- Installed to: .opencode/rules/<group>/<doc>/{loader.md,rule.md}
- Lazy loader must exist: .opencode/rules/_lazy.md

Naming:
- <group>, <doc>, <name> must be kebab-case: ^[a-z0-9]+(-[a-z0-9]+)*$
HELP
}

main() {
  local root
  root="$(project_root)"
  cd "$root"

  local cmd="${1:-}"
  case "$cmd" in
    list)
      cmd_list "${2:-}"
      ;;
    add-rules-lazy)
      add_rules_lazy
      ;;
    add-rule)
      add_rule "${2:-}"
      ;;
    add-skill)
      add_skill "${2:-}"
      ;;
    add-agent)
      add_agent "${2:-}"
      ;;
    update)
      cmd_update
      ;;
    -h|--help|help|"")
      usage
      ;;
    *)
      die "unknown command: $cmd (run: opencode-kit --help)"
      ;;
  esac
}

main "$@"
