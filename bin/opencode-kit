#!/usr/bin/env bash
set -euo pipefail

KIT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
MANIFEST_FILENAME=".opencode-kit.json"

module_version_from_file() {
  local path="$1"

  python3 - "$path" <<'PY'
import re
import sys

path = sys.argv[1]

with open(path, "r", encoding="utf-8") as f:
  text = f.read()

if not text.startswith("---"):
  print("")
  sys.exit(0)

m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
if not m:
  print("")
  sys.exit(0)

frontmatter = m.group(1).splitlines()
for line in frontmatter:
  if line.strip().startswith("version:"):
    value = line.split(":", 1)[1].strip().strip('"').strip("'")
    print(value)
    sys.exit(0)

print("")
PY
}

require_module_version() {
  local path="$1"
  local version

  version="$(module_version_from_file "$path")"
  [[ -n "$version" ]] || die "module is missing version frontmatter: $path"
  [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || die "invalid module version (use semver x.y.z): $version ($path)"

  printf '%s\n' "$version"
}

err() {
  printf 'error: %s\n' "$*" >&2
}

die() {
  err "$*"
  exit 1
}

project_root() {
  if git rev-parse --show-toplevel >/dev/null 2>&1; then
    git rev-parse --show-toplevel
  else
    pwd
  fi
}

validate_kebab() {
  local value="$1"
  [[ "$value" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]] || die "invalid name (use kebab-case): $value"
}

ensure_manifest() {
  if [[ ! -f "$MANIFEST_FILENAME" ]]; then
    cat > "$MANIFEST_FILENAME" <<'JSON'
{
  "version": 2,
  "installed": {
    "module": {}
  }
}
JSON
    return
  fi

  local version
  version="$(python3 - "$MANIFEST_FILENAME" <<'PY'
import json
import sys

with open(sys.argv[1], "r", encoding="utf-8") as f:
  data = json.load(f)

print(data.get("version", ""))
PY
)"

  [[ "$version" == "2" ]] || die "unsupported manifest version: ${version:-<missing>} (expected: 2). Delete .opencode-kit.json and reinstall."
}

json_files_from_pairs() {
  python3 - <<'PY' "$@"
import json
import sys

args = sys.argv[1:]
if len(args) % 2 != 0:
  raise SystemExit("expected src/dst pairs")

files = []
for i in range(0, len(args), 2):
  files.append({"src": args[i], "dst": args[i + 1]})

print(json.dumps(files, ensure_ascii=False))
PY
}

json_set_module() {
  # json_set_module <module_id> <source> <module_version> <files_json>
  local module_id="$1"
  local source="$2"
  local module_version="$3"
  local files_json="$4"

  python3 - "$MANIFEST_FILENAME" "$module_id" "$source" "$module_version" "$files_json" <<'PY'
import datetime
import json
import sys

manifest_path, module_id, source, module_version, files_json = sys.argv[1:]
files = json.loads(files_json)

today = datetime.date.today().isoformat()

with open(manifest_path, "r", encoding="utf-8") as f:
  data = json.load(f)

installed = data.setdefault("installed", {})
modules = installed.setdefault("module", {})

modules[module_id] = {
  "source": source,
  "moduleVersion": module_version,
  "installedAt": today,
  "files": files,
}

with open(manifest_path, "w", encoding="utf-8") as f:
  json.dump(data, f, indent=2, ensure_ascii=False)
  f.write("\n")
PY
}

cmd_list() {
  local kind="${1:-}"
  case "$kind" in
    modules)
      (cd "$KIT_ROOT" && \
        find "modules" -mindepth 3 -maxdepth 3 -type f -name "MODULE.md" 2>/dev/null | \
        sed -e 's#^modules/##' -e 's#/MODULE\.md$##' | \
        sort -u
      )
      ;;
    *)
      die "usage: opencode-kit list modules"
      ;;
  esac
}

add_module() {
  local id="${1:-}"
  [[ -n "$id" ]] || die "usage: opencode-kit add-module <group>/<module>"

  local group="${id%%/*}"
  local module="${id#*/}"
  [[ "$group" != "$id" ]] || die "module id must be <group>/<module> (got: $id)"
  [[ -n "$module" ]] || die "module id must be <group>/<module> (got: $id)"

  validate_kebab "$group"
  validate_kebab "$module"

  local src_dir="$KIT_ROOT/modules/$group/$module"
  [[ -d "$src_dir" ]] || die "module not found: $id ($src_dir)"

  local module_meta="$src_dir/MODULE.md"
  [[ -f "$module_meta" ]] || die "module is missing MODULE.md: $module_meta"

  local module_version
  module_version="$(require_module_version "$module_meta")"

  local -a install_pairs=()
  local -a check_paths=()

  local agents_dir="$src_dir/agents"
  if [[ -d "$agents_dir" ]]; then
    shopt -s nullglob
    local agent
    for agent in "$agents_dir"/*.md; do
      local doc
      doc="$(basename "$agent" .md)"
      validate_kebab "$doc"

      local agent_id
      agent_id="$group-$module-$doc"

      local src_rel
      src_rel="modules/$group/$module/agents/$doc.md"

      local dst
      dst=".opencode/agent/$agent_id.md"

      install_pairs+=("$src_rel" "$dst")
      check_paths+=("$dst")
    done
    shopt -u nullglob
  fi

  local rules_dir="$src_dir/rules"
  if [[ -d "$rules_dir" ]]; then
    shopt -s nullglob
    local rule
    for rule in "$rules_dir"/*.md; do
      local doc
      doc="$(basename "$rule" .md)"
      validate_kebab "$doc"

      local rule_id
      rule_id="$group-$module-$doc"

      local src_rel
      src_rel="modules/$group/$module/rules/$doc.md"

      local dst
      dst=".opencode/rules/$rule_id.md"

      install_pairs+=("$src_rel" "$dst")
      check_paths+=("$dst")
    done
    shopt -u nullglob
  fi

  local skills_dir="$src_dir/skills"
  if [[ -d "$skills_dir" ]]; then
    shopt -s nullglob
    local skill
    for skill in "$skills_dir"/*/SKILL.md; do
      local skill_id
      skill_id="$(basename "$(dirname "$skill")")"
      validate_kebab "$skill_id"

      local src_rel
      src_rel="modules/$group/$module/skills/$skill_id/SKILL.md"

      local dst_dir
      dst_dir=".opencode/skill/$skill_id"

      local dst
      dst="$dst_dir/SKILL.md"

      install_pairs+=("$src_rel" "$dst")
      check_paths+=("$dst_dir" "$dst")
    done
    shopt -u nullglob
  fi

  if [[ "${#install_pairs[@]}" -eq 0 ]]; then
    die "module has no installable content: $id"
  fi

  local path
  for path in "${check_paths[@]}"; do
    if [[ -e "$path" ]]; then
      die "destination already exists: $path"
    fi
  done

  local i
  for ((i = 0; i < ${#install_pairs[@]}; i += 2)); do
    local src_rel="${install_pairs[i]}"
    local dst="${install_pairs[i + 1]}"

    mkdir -p "$(dirname "$dst")"
    cp "$KIT_ROOT/$src_rel" "$dst"
  done

  ensure_manifest

  local files_json
  files_json="$(json_files_from_pairs "${install_pairs[@]}")"

  json_set_module "$id" "modules/$group/$module" "$module_version" "$files_json"

  printf 'installed module: %s\n' "$id"
}

cmd_update() {
  ensure_manifest

  python3 - "$MANIFEST_FILENAME" "$KIT_ROOT" <<'PY'
import datetime
import json
import os
import re
import shutil
import sys

manifest_path, kit_root = sys.argv[1:]

today = datetime.date.today().isoformat()


def load_manifest():
  with open(manifest_path, "r", encoding="utf-8") as f:
    return json.load(f)


def dump_manifest(data):
  with open(manifest_path, "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2, ensure_ascii=False)
    f.write("\n")


def read_frontmatter_version(path):
  try:
    with open(path, "r", encoding="utf-8") as f:
      text = f.read()
  except FileNotFoundError:
    return ""

  if not text.startswith("---"):
    return ""

  m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
  if not m:
    return ""

  for line in m.group(1).splitlines():
    if line.strip().startswith("version:"):
      return line.split(":", 1)[1].strip().strip('"').strip("'")

  return ""


def parse_semver(value, *, context=""):
  value = (value or "").strip()
  m = re.match(r"^(\d+)\.(\d+)\.(\d+)$", value)
  if not m:
    raise ValueError(f"invalid semver x.y.z: {value} ({context})")
  return (int(m.group(1)), int(m.group(2)), int(m.group(3)))


def safe_dst_path(path):
  if os.path.isabs(path):
    raise ValueError(f"absolute path not allowed in manifest: {path}")

  normalized = os.path.normpath(path)
  if normalized == ".." or normalized.startswith(".." + os.sep):
    raise ValueError(f"parent traversal not allowed in manifest: {path}")

  if not (normalized == ".opencode" or normalized.startswith(".opencode" + os.sep)):
    raise ValueError(f"destination must stay under .opencode/: {path}")

  return normalized


def safe_src_path(path):
  if os.path.isabs(path):
    raise ValueError(f"absolute src path not allowed in manifest: {path}")

  normalized = os.path.normpath(path)
  if normalized == ".." or normalized.startswith(".." + os.sep):
    raise ValueError(f"parent traversal not allowed in src: {path}")

  if not (normalized == "modules" or normalized.startswith("modules" + os.sep)):
    raise ValueError(f"src must stay under modules/: {path}")

  return normalized


def module_meta_path(module_id):
  group, module = module_id.split("/", 1)
  return os.path.join(kit_root, "modules", group, module, "MODULE.md")


def update_one(module_id, entry):
  if not isinstance(entry, dict):
    return False

  installed_version = entry.get("moduleVersion")
  if not installed_version:
    raise ValueError(f"moduleVersion missing for module {module_id}")

  files = entry.get("files")
  if not isinstance(files, list) or not files:
    raise ValueError(f"files missing/empty for module {module_id}")

  kit_file = module_meta_path(module_id)
  kit_version = read_frontmatter_version(kit_file)
  if kit_version == "":
    raise ValueError(f"kit module is missing version frontmatter: {kit_file}")

  kit_tuple = parse_semver(kit_version, context=kit_file)
  installed_tuple = parse_semver(installed_version, context=f"manifest module {module_id}")

  should_update = kit_tuple > installed_tuple

  changed = False
  if should_update:
    for file_entry in files:
      if not isinstance(file_entry, dict):
        raise ValueError(f"invalid file entry for module {module_id}: {file_entry}")

      src_rel = safe_src_path(file_entry.get("src") or "")
      dst_rel = safe_dst_path(file_entry.get("dst") or "")

      src = os.path.join(kit_root, src_rel)
      dst = dst_rel

      if not os.path.exists(src):
        raise ValueError(f"kit source missing: {src}")

      os.makedirs(os.path.dirname(dst), exist_ok=True)
      shutil.copyfile(src, dst)

    entry["installedAt"] = today
    entry["moduleVersion"] = kit_version
    changed = True
    print(f"updated module {module_id}: {installed_version} -> {kit_version}")
  else:
    print(f"up-to-date module {module_id}: {installed_version}")

  return changed


manifest = load_manifest()
if manifest.get("version") != 2:
  raise SystemExit("unsupported manifest version (expected 2). Delete .opencode-kit.json and reinstall.")

installed = manifest.get("installed", {})
modules = installed.get("module", {})
if not isinstance(modules, dict):
  raise SystemExit("installed.module must be an object")

modified = False
for module_id, entry in modules.items():
  modified = update_one(module_id, entry) or modified

if modified:
  dump_manifest(manifest)
PY
}

usage() {
  cat <<'HELP'
Usage:
  opencode-kit list modules
  opencode-kit add-module <group>/<module>
  opencode-kit update

Policy:
- Copy only (portable)
- Refuse overwrite: if destination exists, error (except: update overwrites manifest-tracked files)
- Does not edit AGENTS.md or opencode.json
- Writes manifest: .opencode-kit.json (version 2)

Module layout (kit):
- modules/<group>/<module>/MODULE.md
- modules/<group>/<module>/agents/<doc>.md
- modules/<group>/<module>/skills/<skill-id>/SKILL.md
- modules/<group>/<module>/rules/<doc>.md

Install destinations (target repo):
- Agents -> .opencode/agent/<group>-<module>-<doc>.md
- Skills -> .opencode/skill/<skill-id>/SKILL.md
- Rules  -> .opencode/rules/<group>-<module>-<doc>.md

Naming:
- <group>, <module>, <doc>, <skill-id> must be kebab-case: ^[a-z0-9]+(-[a-z0-9]+)*$
HELP
}

main() {
  local root
  root="$(project_root)"
  cd "$root"

  local cmd="${1:-}"
  case "$cmd" in
    list)
      cmd_list "${2:-}"
      ;;
    add-module)
      add_module "${2:-}"
      ;;
    update)
      cmd_update
      ;;
    -h|--help|help|"")
      usage
      ;;
    *)
      die "unknown command: $cmd (run: opencode-kit --help)"
      ;;
  esac
}

main "$@"
