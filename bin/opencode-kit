#!/usr/bin/env bash
set -euo pipefail

KIT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
MANIFEST_FILENAME=".opencode-kit.json"
OPENCODE_CONFIG_FILENAME="opencode.json"
OPENCODE_SCHEMA_URL="https://opencode.ai/config.json"
OPENCODE_AUTOLOAD_GLOB=".opencode/rules/autoload/*.md"

module_version_from_file() {
  local path="$1"

  python3 - "$path" <<'PY'
import re
import sys

path = sys.argv[1]

with open(path, "r", encoding="utf-8") as f:
  text = f.read()

if not text.startswith("---"):
  print("")
  sys.exit(0)

m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
if not m:
  print("")
  sys.exit(0)

frontmatter = m.group(1).splitlines()
for line in frontmatter:
  if line.strip().startswith("version:"):
    value = line.split(":", 1)[1].strip().strip('"').strip("'")
    print(value)
    sys.exit(0)

print("")
PY
}

frontmatter_bool_from_file() {
  # frontmatter_bool_from_file <path> <key>
  local path="$1"
  local key="$2"

  python3 - "$path" "$key" <<'PY'
import re
import sys

path, key = sys.argv[1:]

try:
  with open(path, "r", encoding="utf-8") as f:
    text = f.read()
except FileNotFoundError:
  print("false")
  sys.exit(0)

if not text.startswith("---"):
  print("false")
  sys.exit(0)

m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
if not m:
  print("false")
  sys.exit(0)

for line in m.group(1).splitlines():
  stripped = line.strip()
  if not stripped.startswith(key + ":"):
    continue

  value = stripped.split(":", 1)[1].strip().strip('"').strip("'").lower()
  print("true" if value == "true" else "false")
  sys.exit(0)

print("false")
PY
}

rule_is_autoloaded() {
  frontmatter_bool_from_file "$1" "autoload"
}

require_module_version() {
  local path="$1"
  local version

  version="$(module_version_from_file "$path")"
  [[ -n "$version" ]] || die "module is missing version frontmatter: $path"
  [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || die "invalid module version (use semver x.y.z): $version ($path)"

  printf '%s\n' "$version"
}

err() {
  printf 'error: %s\n' "$*" >&2
}

die() {
  err "$*"
  exit 1
}

project_root() {
  if git rev-parse --show-toplevel >/dev/null 2>&1; then
    git rev-parse --show-toplevel
  else
    pwd
  fi
}

validate_kebab() {
  local value="$1"
  [[ "$value" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]] || die "invalid name (use kebab-case): $value"
}

ensure_manifest() {
  if [[ ! -f "$MANIFEST_FILENAME" ]]; then
    cat > "$MANIFEST_FILENAME" <<'JSON'
{
  "version": 2,
  "installed": {
    "module": {}
  }
}
JSON
    return
  fi

  local version
  version="$(python3 - "$MANIFEST_FILENAME" <<'PY'
import json
import sys

with open(sys.argv[1], "r", encoding="utf-8") as f:
  data = json.load(f)

print(data.get("version", ""))
PY
)"

  [[ "$version" == "2" ]] || die "unsupported manifest version: ${version:-<missing>} (expected: 2). Delete .opencode-kit.json and reinstall."
}

json_files_from_pairs() {
  python3 - <<'PY' "$@"
import json
import sys

args = sys.argv[1:]
if len(args) % 2 != 0:
  raise SystemExit("expected src/dst pairs")

files = []
for i in range(0, len(args), 2):
  files.append({"src": args[i], "dst": args[i + 1]})

print(json.dumps(files, ensure_ascii=False))
PY
}

json_set_module() {
  # json_set_module <module_id> <source> <module_version> <files_json>
  local module_id="$1"
  local source="$2"
  local module_version="$3"
  local files_json="$4"

  python3 - "$MANIFEST_FILENAME" "$module_id" "$source" "$module_version" "$files_json" <<'PY'
import datetime
import json
import sys

manifest_path, module_id, source, module_version, files_json = sys.argv[1:]
files = json.loads(files_json)

today = datetime.date.today().isoformat()

with open(manifest_path, "r", encoding="utf-8") as f:
  data = json.load(f)

installed = data.setdefault("installed", {})
modules = installed.setdefault("module", {})

modules[module_id] = {
  "source": source,
  "moduleVersion": module_version,
  "installedAt": today,
  "files": files,
}

with open(manifest_path, "w", encoding="utf-8") as f:
  json.dump(data, f, indent=2, ensure_ascii=False)
  f.write("\n")
PY
}

cmd_list() {
  local kind="${1:-}"
  case "$kind" in
    modules)
      (cd "$KIT_ROOT" && \
        find "modules" -mindepth 3 -maxdepth 3 -type f -name "MODULE.md" 2>/dev/null | \
        sed -e 's#^modules/##' -e 's#/MODULE\.md$##' | \
        sort -u
      )
      ;;
    *)
      die "usage: opencode-kit list modules"
      ;;
  esac
}

add_module() {
  local id="${1:-}"
  [[ -n "$id" ]] || die "usage: opencode-kit add-module <group>/<module>"

  local group="${id%%/*}"
  local module="${id#*/}"
  [[ "$group" != "$id" ]] || die "module id must be <group>/<module> (got: $id)"
  [[ -n "$module" ]] || die "module id must be <group>/<module> (got: $id)"

  validate_kebab "$group"
  validate_kebab "$module"

  local src_dir="$KIT_ROOT/modules/$group/$module"
  [[ -d "$src_dir" ]] || die "module not found: $id ($src_dir)"

  local module_meta="$src_dir/MODULE.md"
  [[ -f "$module_meta" ]] || die "module is missing MODULE.md: $module_meta"

  local module_version
  module_version="$(require_module_version "$module_meta")"

  local -a install_pairs=()
  local -a check_paths=()

  local agents_dir="$src_dir/agents"
  if [[ -d "$agents_dir" ]]; then
    shopt -s nullglob
    local agent
    for agent in "$agents_dir"/*.md; do
      local doc
      doc="$(basename "$agent" .md)"
      validate_kebab "$doc"

      local agent_id
      agent_id="$group-$module-$doc"

      local src_rel
      src_rel="modules/$group/$module/agents/$doc.md"

      local dst
      dst=".opencode/agent/$agent_id.md"

      install_pairs+=("$src_rel" "$dst")
      check_paths+=("$dst")
    done
    shopt -u nullglob
  fi

  local rules_dir="$src_dir/rules"
  if [[ -d "$rules_dir" ]]; then
    shopt -s nullglob
    local rule
    for rule in "$rules_dir"/*.md; do
      local doc
      doc="$(basename "$rule" .md)"
      validate_kebab "$doc"

      local rule_id
      rule_id="$group-$module-$doc"

      local src_rel
      src_rel="modules/$group/$module/rules/$doc.md"

      local dst_dir
      if [[ "$(rule_is_autoloaded "$rule")" == "true" ]]; then
        dst_dir=".opencode/rules/autoload"
      else
        dst_dir=".opencode/rules/ondemand"
      fi

      local dst
      dst="$dst_dir/$rule_id.md"

      install_pairs+=("$src_rel" "$dst")
      check_paths+=("$dst")
    done
    shopt -u nullglob
  fi

  local skills_dir="$src_dir/skills"
  if [[ -d "$skills_dir" ]]; then
    shopt -s nullglob
    local skill
    for skill in "$skills_dir"/*/SKILL.md; do
      local skill_id
      skill_id="$(basename "$(dirname "$skill")")"
      validate_kebab "$skill_id"

      local src_rel
      src_rel="modules/$group/$module/skills/$skill_id/SKILL.md"

      local dst_dir
      dst_dir=".opencode/skill/$skill_id"

      local dst
      dst="$dst_dir/SKILL.md"

      install_pairs+=("$src_rel" "$dst")
      check_paths+=("$dst_dir" "$dst")
    done
    shopt -u nullglob
  fi

  if [[ "${#install_pairs[@]}" -eq 0 ]]; then
    die "module has no installable content: $id"
  fi

  local path
  for path in "${check_paths[@]}"; do
    if [[ -e "$path" ]]; then
      die "destination already exists: $path"
    fi
  done

  local i
  for ((i = 0; i < ${#install_pairs[@]}; i += 2)); do
    local src_rel="${install_pairs[i]}"
    local dst="${install_pairs[i + 1]}"

    mkdir -p "$(dirname "$dst")"
    cp "$KIT_ROOT/$src_rel" "$dst"
  done

  ensure_manifest

  local files_json
  files_json="$(json_files_from_pairs "${install_pairs[@]}")"

  json_set_module "$id" "modules/$group/$module" "$module_version" "$files_json"

  printf 'installed module: %s\n' "$id"
}

cmd_init() {
  local config_file="$OPENCODE_CONFIG_FILENAME"

  python3 - "$config_file" "$OPENCODE_SCHEMA_URL" "$OPENCODE_AUTOLOAD_GLOB" <<'PY'
import json
import sys

config_file, schema_url, autoload_glob = sys.argv[1:]


def dump_config(data):
  with open(config_file, "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2, ensure_ascii=False)
    f.write("\n")


try:
  with open(config_file, "r", encoding="utf-8") as f:
    data = json.load(f)
  exists = True
except FileNotFoundError:
  data = {}
  exists = False
except json.JSONDecodeError as e:
  raise SystemExit(f"error: invalid JSON in {config_file}: {e}")

if not isinstance(data, dict):
  raise SystemExit(f"error: {config_file} must be a JSON object")

changed = False

if data.get("$schema") != schema_url:
  data["$schema"] = schema_url
  changed = True

instructions = data.get("instructions")
if instructions is None:
  instructions = []
  data["instructions"] = instructions
  changed = True

if not isinstance(instructions, list) or not all(isinstance(x, str) for x in instructions):
  raise SystemExit(f"error: {config_file}: instructions must be an array of strings")

if autoload_glob not in instructions:
  instructions.append(autoload_glob)
  changed = True

if changed:
  dump_config(data)
  if exists:
    print(f"updated {config_file} (added: {autoload_glob})")
  else:
    print(f"created {config_file} (added: {autoload_glob})")
else:
  print(f"{config_file} already configured")
PY
}

cmd_update() {
  ensure_manifest

  python3 - "$MANIFEST_FILENAME" "$KIT_ROOT" <<'PY'
import datetime
import json
import os
import re
import shutil
import sys

manifest_path, kit_root = sys.argv[1:]

today = datetime.date.today().isoformat()


def load_manifest():
  with open(manifest_path, "r", encoding="utf-8") as f:
    return json.load(f)


def dump_manifest(data):
  with open(manifest_path, "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2, ensure_ascii=False)
    f.write("\n")


def read_frontmatter(path):
  try:
    with open(path, "r", encoding="utf-8") as f:
      text = f.read()
  except FileNotFoundError:
    return None

  if not text.startswith("---"):
    return None

  m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
  if not m:
    return None

  return m.group(1).splitlines()


def read_frontmatter_version(path):
  frontmatter = read_frontmatter(path)
  if not frontmatter:
    return ""

  for line in frontmatter:
    if line.strip().startswith("version:"):
      return line.split(":", 1)[1].strip().strip('"').strip("'")

  return ""


def read_frontmatter_bool(path, key):
  frontmatter = read_frontmatter(path)
  if not frontmatter:
    return False

  prefix = key + ":"
  for line in frontmatter:
    stripped = line.strip()
    if not stripped.startswith(prefix):
      continue

    value = stripped.split(":", 1)[1].strip().strip('"').strip("'").lower()
    return value == "true"

  return False


def parse_semver(value, *, context=""):
  value = (value or "").strip()
  m = re.match(r"^(\d+)\.(\d+)\.(\d+)$", value)
  if not m:
    raise ValueError(f"invalid semver x.y.z: {value} ({context})")
  return (int(m.group(1)), int(m.group(2)), int(m.group(3)))


def safe_dst_path(path):
  if os.path.isabs(path):
    raise ValueError(f"absolute path not allowed in manifest: {path}")

  normalized = os.path.normpath(path)
  if normalized == ".." or normalized.startswith(".." + os.sep):
    raise ValueError(f"parent traversal not allowed in manifest: {path}")

  if not (normalized == ".opencode" or normalized.startswith(".opencode" + os.sep)):
    raise ValueError(f"destination must stay under .opencode/: {path}")

  return normalized


def safe_src_path(path):
  if os.path.isabs(path):
    raise ValueError(f"absolute src path not allowed in manifest: {path}")

  normalized = os.path.normpath(path)
  if normalized == ".." or normalized.startswith(".." + os.sep):
    raise ValueError(f"parent traversal not allowed in src: {path}")

  if not (normalized == "modules" or normalized.startswith("modules" + os.sep)):
    raise ValueError(f"src must stay under modules/: {path}")

  return normalized


def module_meta_path(module_id):
  group, module = module_id.split("/", 1)
  return os.path.join(kit_root, "modules", group, module, "MODULE.md")


def is_rule_src(src_rel):
  parts = src_rel.split(os.sep)
  return (
    len(parts) == 5
    and parts[0] == "modules"
    and parts[3] == "rules"
    and parts[4].endswith(".md")
  )


def desired_dst_for_rule_src(src_rel):
  parts = src_rel.split(os.sep)
  group = parts[1]
  module = parts[2]
  doc = os.path.splitext(parts[4])[0]
  rule_id = f"{group}-{module}-{doc}"

  src = os.path.join(kit_root, src_rel)
  autoload = read_frontmatter_bool(src, "autoload")
  folder = "autoload" if autoload else "ondemand"

  return os.path.join(".opencode", "rules", folder, f"{rule_id}.md")


def collect_module_files(module_id):
  group, module = module_id.split("/", 1)
  src_dir = os.path.join(kit_root, "modules", group, module)
  if not os.path.isdir(src_dir):
    raise ValueError(f"kit module not found: {src_dir}")

  files = []

  agents_dir = os.path.join(src_dir, "agents")
  if os.path.isdir(agents_dir):
    for entry in sorted(os.listdir(agents_dir)):
      if not entry.endswith(".md"):
        continue
      doc = os.path.splitext(entry)[0]
      src_rel = os.path.join("modules", group, module, "agents", entry)
      dst_rel = os.path.join(".opencode", "agent", f"{group}-{module}-{doc}.md")
      files.append({"src": safe_src_path(src_rel), "dst": safe_dst_path(dst_rel)})

  rules_dir = os.path.join(src_dir, "rules")
  if os.path.isdir(rules_dir):
    for entry in sorted(os.listdir(rules_dir)):
      if not entry.endswith(".md"):
        continue
      src_rel = os.path.join("modules", group, module, "rules", entry)
      dst_rel = desired_dst_for_rule_src(src_rel)
      files.append({"src": safe_src_path(src_rel), "dst": safe_dst_path(dst_rel)})

  skills_dir = os.path.join(src_dir, "skills")
  if os.path.isdir(skills_dir):
    for skill_id in sorted(os.listdir(skills_dir)):
      skill_file = os.path.join(skills_dir, skill_id, "SKILL.md")
      if not os.path.isfile(skill_file):
        continue
      src_rel = os.path.join("modules", group, module, "skills", skill_id, "SKILL.md")
      dst_rel = os.path.join(".opencode", "skill", skill_id, "SKILL.md")
      files.append({"src": safe_src_path(src_rel), "dst": safe_dst_path(dst_rel)})

  if not files:
    raise ValueError(f"module has no installable content: {module_id}")

  return files


def update_one(module_id, entry):
  if not isinstance(entry, dict):
    return False

  installed_version = entry.get("moduleVersion")
  if not installed_version:
    raise ValueError(f"moduleVersion missing for module {module_id}")

  files = entry.get("files")
  if not isinstance(files, list) or not files:
    raise ValueError(f"files missing/empty for module {module_id}")

  kit_file = module_meta_path(module_id)
  kit_version = read_frontmatter_version(kit_file)
  if kit_version == "":
    raise ValueError(f"kit module is missing version frontmatter: {kit_file}")

  kit_tuple = parse_semver(kit_version, context=kit_file)
  installed_tuple = parse_semver(installed_version, context=f"manifest module {module_id}")

  should_update = kit_tuple > installed_tuple

  changed = False
  if should_update:
    expected_files = collect_module_files(module_id)

    existing_by_src = {}
    for file_entry in files:
      if not isinstance(file_entry, dict):
        raise ValueError(f"invalid file entry for module {module_id}: {file_entry}")

      src_rel = safe_src_path(file_entry.get("src") or "")
      dst_rel = safe_dst_path(file_entry.get("dst") or "")
      existing_by_src[src_rel] = dst_rel

    processed_src = set()
    result_files = []

    for expected in expected_files:
      src_rel = safe_src_path(expected.get("src") or "")
      dst_rel = safe_dst_path(expected.get("dst") or "")

      src = os.path.join(kit_root, src_rel)
      if not os.path.exists(src):
        raise ValueError(f"kit source missing: {src}")

      old_dst_rel = existing_by_src.get(src_rel)

      # Policy A: refuse overwrite for newly introduced files.
      if old_dst_rel is None and os.path.exists(dst_rel):
        raise ValueError(f"destination already exists: {dst_rel} (new file for module {module_id})")

      # Also refuse overwrite when moving a file to a new destination.
      if old_dst_rel is not None and dst_rel != old_dst_rel and os.path.exists(dst_rel):
        raise ValueError(f"destination already exists: {dst_rel} (moving from {old_dst_rel})")

      os.makedirs(os.path.dirname(dst_rel), exist_ok=True)
      shutil.copyfile(src, dst_rel)

      if old_dst_rel is not None and dst_rel != old_dst_rel:
        if os.path.exists(old_dst_rel):
          os.remove(old_dst_rel)

      result_files.append({"src": src_rel, "dst": dst_rel})
      processed_src.add(src_rel)

    # Remove files that were installed previously but are no longer in the module.
    for src_rel, old_dst_rel in existing_by_src.items():
      if src_rel in processed_src:
        continue
      if os.path.exists(old_dst_rel):
        os.remove(old_dst_rel)

    entry["files"] = result_files
    entry["installedAt"] = today
    entry["moduleVersion"] = kit_version
    changed = True
    print(f"updated module {module_id}: {installed_version} -> {kit_version}")
  else:
    print(f"up-to-date module {module_id}: {installed_version}")

  return changed


manifest = load_manifest()
if manifest.get("version") != 2:
  raise SystemExit("unsupported manifest version (expected 2). Delete .opencode-kit.json and reinstall.")

installed = manifest.get("installed", {})
modules = installed.get("module", {})
if not isinstance(modules, dict):
  raise SystemExit("installed.module must be an object")

modified = False
for module_id, entry in modules.items():
  modified = update_one(module_id, entry) or modified

if modified:
  dump_manifest(manifest)
PY
}

cmd_status() {
  python3 - "$MANIFEST_FILENAME" "$KIT_ROOT" <<'PY'
import json
import os
import re
import sys

manifest_path, kit_root = sys.argv[1:]


def read_frontmatter(path):
  try:
    with open(path, "r", encoding="utf-8") as f:
      text = f.read()
  except FileNotFoundError:
    return None

  if not text.startswith("---"):
    return None

  m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
  if not m:
    return None

  return m.group(1).splitlines()


def read_frontmatter_version(path):
  frontmatter = read_frontmatter(path)
  if not frontmatter:
    return ""

  for line in frontmatter:
    if line.strip().startswith("version:"):
      return line.split(":", 1)[1].strip().strip('"').strip("'")

  return ""


def parse_semver(value, *, context=""):
  value = (value or "").strip()
  m = re.match(r"^(\d+)\.(\d+)\.(\d+)$", value)
  if not m:
    raise ValueError(f"invalid semver x.y.z: {value} ({context})")
  return (int(m.group(1)), int(m.group(2)), int(m.group(3)))


def safe_dst_path(path):
  if os.path.isabs(path):
    raise ValueError(f"absolute path not allowed in manifest: {path}")

  normalized = os.path.normpath(path)
  if normalized == ".." or normalized.startswith(".." + os.sep):
    raise ValueError(f"parent traversal not allowed in manifest: {path}")

  if not (normalized == ".opencode" or normalized.startswith(".opencode" + os.sep)):
    raise ValueError(f"destination must stay under .opencode/: {path}")

  return normalized


def safe_src_path(path):
  if os.path.isabs(path):
    raise ValueError(f"absolute src path not allowed in manifest: {path}")

  normalized = os.path.normpath(path)
  if normalized == ".." or normalized.startswith(".." + os.sep):
    raise ValueError(f"parent traversal not allowed in src: {path}")

  if not (normalized == "modules" or normalized.startswith("modules" + os.sep)):
    raise ValueError(f"src must stay under modules/: {path}")

  return normalized


def module_meta_path(module_id):
  group, module = module_id.split("/", 1)
  return os.path.join(kit_root, "modules", group, module, "MODULE.md")


def bytes_equal(path_a, path_b):
  with open(path_a, "rb") as f:
    a = f.read()
  with open(path_b, "rb") as f:
    b = f.read()
  return a == b


if not os.path.isfile(manifest_path):
  print("nothing installed")
  raise SystemExit(0)

try:
  with open(manifest_path, "r", encoding="utf-8") as f:
    manifest = json.load(f)
except json.JSONDecodeError as e:
  print(f"error: invalid JSON in {manifest_path}: {e}")
  raise SystemExit(2)

if manifest.get("version") != 2:
  print("error: unsupported manifest version (expected 2). Delete .opencode-kit.json and reinstall.")
  raise SystemExit(2)

installed = manifest.get("installed", {})
modules = installed.get("module", {})
if not isinstance(modules, dict):
  print("error: installed.module must be an object")
  raise SystemExit(2)

if not modules:
  print("nothing installed")
  raise SystemExit(0)

updates = 0
missing = 0
dirty_modules = 0
ok = 0
has_problems = False

for module_id in sorted(modules.keys()):
  entry = modules.get(module_id)
  if not isinstance(entry, dict):
    print(f"{module_id} (invalid manifest entry)")
    has_problems = True
    continue

  installed_version = entry.get("moduleVersion")
  if not installed_version:
    print(f"{module_id} (missing moduleVersion)")
    has_problems = True
    continue

  try:
    installed_tuple = parse_semver(installed_version, context=f"manifest module {module_id}")
  except ValueError as e:
    print(f"error: {e}")
    raise SystemExit(2)

  files = entry.get("files")
  if not isinstance(files, list) or not files:
    print(f"{module_id} {installed_version} (missing files)")
    has_problems = True
    continue

  kit_file = module_meta_path(module_id)
  kit_exists = os.path.isfile(kit_file)
  kit_version = read_frontmatter_version(kit_file) if kit_exists else ""
  if kit_exists and kit_version == "":
    print(f"error: kit module is missing version frontmatter: {kit_file}")
    raise SystemExit(2)

  tokens = []
  dirty_count = 0

  # Dirty check: compare each installed file to kit source.
  if kit_version:
    for file_entry in files:
      if not isinstance(file_entry, dict):
        print(f"error: invalid file entry for module {module_id}: {file_entry}")
        raise SystemExit(2)

      src_rel = safe_src_path(file_entry.get("src") or "")
      dst_rel = safe_dst_path(file_entry.get("dst") or "")

      src = os.path.join(kit_root, src_rel)
      dst = dst_rel

      if not os.path.exists(dst):
        dirty_count += 1
        continue

      if os.path.isdir(dst):
        dirty_count += 1
        continue

      if not os.path.exists(src) or os.path.isdir(src):
        dirty_count += 1
        continue

      if not bytes_equal(src, dst):
        dirty_count += 1
  else:
    missing += 1
    tokens.append("missing-in-kit")

  # Version comparison.
  display_version = installed_version
  if kit_version:
    try:
      kit_tuple = parse_semver(kit_version, context=kit_file)
    except ValueError as e:
      print(f"error: {e}")
      raise SystemExit(2)

    if kit_tuple > installed_tuple:
      updates += 1
      tokens.append("update")
      display_version = f"{installed_version} -> {kit_version}"
    elif kit_tuple < installed_tuple:
      tokens.append("downgrade")
      display_version = f"{installed_version} -> {kit_version}"

  if dirty_count > 0:
    dirty_modules += 1
    tokens.append(f"dirty:{dirty_count}")

  if not tokens:
    ok += 1
    print(f"{module_id} {installed_version} (up-to-date)")
  else:
    has_problems = True
    print(f"{module_id} {display_version} ({', '.join(tokens)})")

print(f"updates: {updates}, dirty: {dirty_modules}, missing: {missing}, ok: {ok}")
raise SystemExit(1 if has_problems else 0)
PY
}

cmd_remove_module() {
  local id="${1:-}"
  [[ -n "$id" ]] || die "usage: opencode-kit remove-module <group>/<module>"

  local group="${id%%/*}"
  local module="${id#*/}"
  [[ "$group" != "$id" ]] || die "module id must be <group>/<module> (got: $id)"
  [[ -n "$module" ]] || die "module id must be <group>/<module> (got: $id)"

  validate_kebab "$group"
  validate_kebab "$module"

  ensure_manifest

  python3 - "$MANIFEST_FILENAME" "$id" <<'PY'
import json
import os
import sys

manifest_path, module_id = sys.argv[1:]


def load_manifest():
  with open(manifest_path, "r", encoding="utf-8") as f:
    return json.load(f)


def dump_manifest(data):
  with open(manifest_path, "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2, ensure_ascii=False)
    f.write("\n")


def safe_dst_path(path):
  if os.path.isabs(path):
    raise ValueError(f"absolute path not allowed in manifest: {path}")

  normalized = os.path.normpath(path)
  if normalized == ".." or normalized.startswith(".." + os.sep):
    raise ValueError(f"parent traversal not allowed in manifest: {path}")

  if not (normalized == ".opencode" or normalized.startswith(".opencode" + os.sep)):
    raise ValueError(f"destination must stay under .opencode/: {path}")

  return normalized


manifest = load_manifest()
if manifest.get("version") != 2:
  raise SystemExit("error: unsupported manifest version (expected 2). Delete .opencode-kit.json and reinstall.")

installed = manifest.get("installed", {})
modules = installed.get("module", {})
if not isinstance(modules, dict):
  raise SystemExit("error: installed.module must be an object")

entry = modules.get(module_id)
if entry is None:
  raise SystemExit(f"error: module is not installed: {module_id}")

if not isinstance(entry, dict):
  raise SystemExit(f"error: invalid module entry for {module_id}")

files = entry.get("files")
if not isinstance(files, list) or not files:
  raise SystemExit(f"error: files missing/empty for module {module_id}")

removed_paths = []
for file_entry in files:
  if not isinstance(file_entry, dict):
    raise SystemExit(f"error: invalid file entry for module {module_id}: {file_entry}")

  dst_rel = safe_dst_path(file_entry.get("dst") or "")
  removed_paths.append(dst_rel)

  if os.path.exists(dst_rel):
    if os.path.isdir(dst_rel):
      raise SystemExit(f"error: expected file but found directory: {dst_rel}")
    os.remove(dst_rel)
    print(f"removed file: {dst_rel}")
  else:
    print(f"warn: missing file: {dst_rel}")

# Prune empty parent directories (stop at .opencode/).
parents = set()
for dst_rel in removed_paths:
  parent = os.path.dirname(dst_rel)
  while parent and parent != ".opencode" and parent.startswith(".opencode" + os.sep):
    parents.add(parent)
    parent = os.path.dirname(parent)

for path in sorted(parents, key=len, reverse=True):
  try:
    os.rmdir(path)
    print(f"removed empty dir: {path}")
  except OSError:
    pass

del modules[module_id]
dump_manifest(manifest)

print(f"removed module: {module_id}")
PY
}

usage() {
  cat <<'HELP'
Usage:
  opencode-kit list modules
  opencode-kit status
  opencode-kit init
  opencode-kit add-module <group>/<module>
  opencode-kit remove-module <group>/<module>
  opencode-kit update

Policy:
- Copy only (portable)
- Refuse overwrite: if destination exists, error (except: update overwrites manifest-tracked files)
- Does not edit target AGENTS.md; only 'init' updates opencode.json
- Writes manifest: .opencode-kit.json (version 2)

Module layout (kit):
- modules/<group>/<module>/MODULE.md
- modules/<group>/<module>/agents/<doc>.md
- modules/<group>/<module>/skills/<skill-id>/SKILL.md
- modules/<group>/<module>/rules/<doc>.md

Install destinations (target repo):
- Agents -> .opencode/agent/<group>-<module>-<doc>.md
- Skills -> .opencode/skill/<skill-id>/SKILL.md
- Rules  -> .opencode/rules/autoload/<group>-<module>-<doc>.md (if rule has frontmatter: autoload: true)
- Rules  -> .opencode/rules/ondemand/<group>-<module>-<doc>.md (default)

Naming:
- <group>, <module>, <doc>, <skill-id> must be kebab-case: ^[a-z0-9]+(-[a-z0-9]+)*$
HELP
}

main() {
  local root
  root="$(project_root)"
  cd "$root"

  local cmd="${1:-}"
  case "$cmd" in
    list)
      cmd_list "${2:-}"
      ;;
    status)
      cmd_status
      ;;
    init)
      cmd_init
      ;;
    add-module)
      add_module "${2:-}"
      ;;
    update)
      cmd_update
      ;;
    remove-module)
      cmd_remove_module "${2:-}"
      ;;
    -h|--help|help|"")
      usage
      ;;
    *)
      die "unknown command: $cmd (run: opencode-kit --help)"
      ;;
  esac
}

main "$@"
