#!/usr/bin/env bash
set -euo pipefail

KIT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
MANIFEST_FILENAME=".opencode-kit.json"
OPENCODE_CONFIG_FILENAME="opencode.json"
OPENCODE_SCHEMA_URL="https://opencode.ai/config.json"
OPENCODE_AUTOLOAD_GLOB=".opencode/rules/autoload/*.md"

module_version_from_file() {
  local path="$1"

  python3 - "$path" <<'PY'
import re
import sys

path = sys.argv[1]

with open(path, "r", encoding="utf-8") as f:
  text = f.read()

if not text.startswith("---"):
  print("")
  sys.exit(0)

m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
if not m:
  print("")
  sys.exit(0)

frontmatter = m.group(1).splitlines()
for line in frontmatter:
  if line.strip().startswith("version:"):
    value = line.split(":", 1)[1].strip().strip('"').strip("'")
    print(value)
    sys.exit(0)

print("")
PY
}

frontmatter_bool_from_file() {
  # frontmatter_bool_from_file <path> <key>
  local path="$1"
  local key="$2"

  python3 - "$path" "$key" <<'PY'
import re
import sys

path, key = sys.argv[1:]

try:
  with open(path, "r", encoding="utf-8") as f:
    text = f.read()
except FileNotFoundError:
  print("false")
  sys.exit(0)

if not text.startswith("---"):
  print("false")
  sys.exit(0)

m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
if not m:
  print("false")
  sys.exit(0)

for line in m.group(1).splitlines():
  stripped = line.strip()
  if not stripped.startswith(key + ":"):
    continue

  value = stripped.split(":", 1)[1].strip().strip('"').strip("'").lower()
  print("true" if value == "true" else "false")
  sys.exit(0)

print("false")
PY
}

rule_is_autoloaded() {
  frontmatter_bool_from_file "$1" "autoload"
}

require_module_version() {
  local path="$1"
  local version

  version="$(module_version_from_file "$path")"
  [[ -n "$version" ]] || die "module is missing version frontmatter: $path"
  [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || die "invalid module version (use semver x.y.z): $version ($path)"

  printf '%s\n' "$version"
}

err() {
  printf 'error: %s\n' "$*" >&2
}

die() {
  err "$*"
  exit 1
}

project_root() {
  if git rev-parse --show-toplevel >/dev/null 2>&1; then
    git rev-parse --show-toplevel
  else
    pwd
  fi
}

validate_kebab() {
  local value="$1"
  [[ "$value" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]] || die "invalid name (use kebab-case): $value"
}

ensure_manifest() {
  if [[ ! -f "$MANIFEST_FILENAME" ]]; then
    cat > "$MANIFEST_FILENAME" <<'JSON'
{
  "version": 2,
  "installed": {
    "module": {}
  }
}
JSON
    return
  fi

  local version
  version="$(python3 - "$MANIFEST_FILENAME" <<'PY'
import json
import sys

with open(sys.argv[1], "r", encoding="utf-8") as f:
  data = json.load(f)

print(data.get("version", ""))
PY
)"

  [[ "$version" == "2" ]] || die "unsupported manifest version: ${version:-<missing>} (expected: 2). Delete .opencode-kit.json and reinstall."
}

json_files_from_pairs() {
  python3 - <<'PY' "$@"
import json
import sys

args = sys.argv[1:]
if len(args) % 2 != 0:
  raise SystemExit("expected src/dst pairs")

files = []
for i in range(0, len(args), 2):
  files.append({"src": args[i], "dst": args[i + 1]})

print(json.dumps(files, ensure_ascii=False))
PY
}

json_set_module() {
  # json_set_module <module_id> <source> <module_version> <files_json>
  local module_id="$1"
  local source="$2"
  local module_version="$3"
  local files_json="$4"

  python3 - "$MANIFEST_FILENAME" "$module_id" "$source" "$module_version" "$files_json" <<'PY'
import datetime
import json
import sys

manifest_path, module_id, source, module_version, files_json = sys.argv[1:]
files = json.loads(files_json)

today = datetime.date.today().isoformat()

with open(manifest_path, "r", encoding="utf-8") as f:
  data = json.load(f)

installed = data.setdefault("installed", {})
modules = installed.setdefault("module", {})

modules[module_id] = {
  "source": source,
  "moduleVersion": module_version,
  "installedAt": today,
  "files": files,
}

with open(manifest_path, "w", encoding="utf-8") as f:
  json.dump(data, f, indent=2, ensure_ascii=False)
  f.write("\n")
PY
}

cmd_list() {
  local kind="${1:-}"
  case "$kind" in
    modules)
      (cd "$KIT_ROOT" && \
        find "modules" -mindepth 3 -maxdepth 3 -type f -name "MODULE.md" 2>/dev/null | \
        sed -e 's#^modules/##' -e 's#/MODULE\.md$##' | \
        sort -u
      )
      ;;
    *)
      die "usage: opencode-kit list modules"
      ;;
  esac
}

add_module() {
  local id="${1:-}"
  [[ -n "$id" ]] || die "usage: opencode-kit add-module <group>/<module>"

  local group="${id%%/*}"
  local module="${id#*/}"
  [[ "$group" != "$id" ]] || die "module id must be <group>/<module> (got: $id)"
  [[ -n "$module" ]] || die "module id must be <group>/<module> (got: $id)"

  validate_kebab "$group"
  validate_kebab "$module"

  local src_dir="$KIT_ROOT/modules/$group/$module"
  [[ -d "$src_dir" ]] || die "module not found: $id ($src_dir)"

  local module_meta="$src_dir/MODULE.md"
  [[ -f "$module_meta" ]] || die "module is missing MODULE.md: $module_meta"

  local module_version
  module_version="$(require_module_version "$module_meta")"

  local -a install_pairs=()
  local -a check_paths=()

  local agents_dir="$src_dir/agents"
  if [[ -d "$agents_dir" ]]; then
    shopt -s nullglob
    local agent
    for agent in "$agents_dir"/*.md; do
      local doc
      doc="$(basename "$agent" .md)"
      validate_kebab "$doc"

      local agent_id
      agent_id="$group-$module-$doc"

      local src_rel
      src_rel="modules/$group/$module/agents/$doc.md"

      local dst
      dst=".opencode/agent/$agent_id.md"

      install_pairs+=("$src_rel" "$dst")
      check_paths+=("$dst")
    done
    shopt -u nullglob
  fi

  local rules_dir="$src_dir/rules"
  if [[ -d "$rules_dir" ]]; then
    shopt -s nullglob
    local rule
    for rule in "$rules_dir"/*.md; do
      local doc
      doc="$(basename "$rule" .md)"
      validate_kebab "$doc"

      local rule_id
      rule_id="$group-$module-$doc"

      local src_rel
      src_rel="modules/$group/$module/rules/$doc.md"

      local dst_dir
      if [[ "$(rule_is_autoloaded "$rule")" == "true" ]]; then
        dst_dir=".opencode/rules/autoload"
      else
        dst_dir=".opencode/rules/ondemand"
      fi

      local dst
      dst="$dst_dir/$rule_id.md"

      install_pairs+=("$src_rel" "$dst")
      check_paths+=("$dst")
    done
    shopt -u nullglob
  fi

  local skills_dir="$src_dir/skills"
  if [[ -d "$skills_dir" ]]; then
    shopt -s nullglob
    local skill
    for skill in "$skills_dir"/*/SKILL.md; do
      local skill_id
      skill_id="$(basename "$(dirname "$skill")")"
      validate_kebab "$skill_id"

      local src_rel
      src_rel="modules/$group/$module/skills/$skill_id/SKILL.md"

      local dst_dir
      dst_dir=".opencode/skill/$skill_id"

      local dst
      dst="$dst_dir/SKILL.md"

      install_pairs+=("$src_rel" "$dst")
      check_paths+=("$dst_dir" "$dst")
    done
    shopt -u nullglob
  fi

  if [[ "${#install_pairs[@]}" -eq 0 ]]; then
    die "module has no installable content: $id"
  fi

  local path
  for path in "${check_paths[@]}"; do
    if [[ -e "$path" ]]; then
      die "destination already exists: $path"
    fi
  done

  local i
  for ((i = 0; i < ${#install_pairs[@]}; i += 2)); do
    local src_rel="${install_pairs[i]}"
    local dst="${install_pairs[i + 1]}"

    mkdir -p "$(dirname "$dst")"
    cp "$KIT_ROOT/$src_rel" "$dst"
  done

  ensure_manifest

  local files_json
  files_json="$(json_files_from_pairs "${install_pairs[@]}")"

  json_set_module "$id" "modules/$group/$module" "$module_version" "$files_json"

  printf 'installed module: %s\n' "$id"
}

cmd_init() {
  local config_file="$OPENCODE_CONFIG_FILENAME"

  python3 - "$config_file" "$OPENCODE_SCHEMA_URL" "$OPENCODE_AUTOLOAD_GLOB" <<'PY'
import json
import sys

config_file, schema_url, autoload_glob = sys.argv[1:]


def dump_config(data):
  with open(config_file, "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2, ensure_ascii=False)
    f.write("\n")


try:
  with open(config_file, "r", encoding="utf-8") as f:
    data = json.load(f)
  exists = True
except FileNotFoundError:
  data = {}
  exists = False
except json.JSONDecodeError as e:
  raise SystemExit(f"error: invalid JSON in {config_file}: {e}")

if not isinstance(data, dict):
  raise SystemExit(f"error: {config_file} must be a JSON object")

changed = False

if data.get("$schema") != schema_url:
  data["$schema"] = schema_url
  changed = True

instructions = data.get("instructions")
if instructions is None:
  instructions = []
  data["instructions"] = instructions
  changed = True

if not isinstance(instructions, list) or not all(isinstance(x, str) for x in instructions):
  raise SystemExit(f"error: {config_file}: instructions must be an array of strings")

if autoload_glob not in instructions:
  instructions.append(autoload_glob)
  changed = True

if changed:
  dump_config(data)
  if exists:
    print(f"updated {config_file} (added: {autoload_glob})")
  else:
    print(f"created {config_file} (added: {autoload_glob})")
else:
  print(f"{config_file} already configured")
PY
}

cmd_update() {
  ensure_manifest

  python3 - "$MANIFEST_FILENAME" "$KIT_ROOT" <<'PY'
import datetime
import json
import os
import re
import shutil
import sys

manifest_path, kit_root = sys.argv[1:]

today = datetime.date.today().isoformat()


def load_manifest():
  with open(manifest_path, "r", encoding="utf-8") as f:
    return json.load(f)


def dump_manifest(data):
  with open(manifest_path, "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2, ensure_ascii=False)
    f.write("\n")


def read_frontmatter(path):
  try:
    with open(path, "r", encoding="utf-8") as f:
      text = f.read()
  except FileNotFoundError:
    return None

  if not text.startswith("---"):
    return None

  m = re.match(r"^---\s*\n(.*?)\n---\s*\n", text, re.S)
  if not m:
    return None

  return m.group(1).splitlines()


def read_frontmatter_version(path):
  frontmatter = read_frontmatter(path)
  if not frontmatter:
    return ""

  for line in frontmatter:
    if line.strip().startswith("version:"):
      return line.split(":", 1)[1].strip().strip('"').strip("'")

  return ""


def read_frontmatter_bool(path, key):
  frontmatter = read_frontmatter(path)
  if not frontmatter:
    return False

  prefix = key + ":"
  for line in frontmatter:
    stripped = line.strip()
    if not stripped.startswith(prefix):
      continue

    value = stripped.split(":", 1)[1].strip().strip('"').strip("'").lower()
    return value == "true"

  return False


def parse_semver(value, *, context=""):
  value = (value or "").strip()
  m = re.match(r"^(\d+)\.(\d+)\.(\d+)$", value)
  if not m:
    raise ValueError(f"invalid semver x.y.z: {value} ({context})")
  return (int(m.group(1)), int(m.group(2)), int(m.group(3)))


def safe_dst_path(path):
  if os.path.isabs(path):
    raise ValueError(f"absolute path not allowed in manifest: {path}")

  normalized = os.path.normpath(path)
  if normalized == ".." or normalized.startswith(".." + os.sep):
    raise ValueError(f"parent traversal not allowed in manifest: {path}")

  if not (normalized == ".opencode" or normalized.startswith(".opencode" + os.sep)):
    raise ValueError(f"destination must stay under .opencode/: {path}")

  return normalized


def safe_src_path(path):
  if os.path.isabs(path):
    raise ValueError(f"absolute src path not allowed in manifest: {path}")

  normalized = os.path.normpath(path)
  if normalized == ".." or normalized.startswith(".." + os.sep):
    raise ValueError(f"parent traversal not allowed in src: {path}")

  if not (normalized == "modules" or normalized.startswith("modules" + os.sep)):
    raise ValueError(f"src must stay under modules/: {path}")

  return normalized


def module_meta_path(module_id):
  group, module = module_id.split("/", 1)
  return os.path.join(kit_root, "modules", group, module, "MODULE.md")


def is_rule_src(src_rel):
  parts = src_rel.split(os.sep)
  return (
    len(parts) == 5
    and parts[0] == "modules"
    and parts[3] == "rules"
    and parts[4].endswith(".md")
  )


def desired_dst_for_rule_src(src_rel):
  parts = src_rel.split(os.sep)
  group = parts[1]
  module = parts[2]
  doc = os.path.splitext(parts[4])[0]
  rule_id = f"{group}-{module}-{doc}"

  src = os.path.join(kit_root, src_rel)
  autoload = read_frontmatter_bool(src, "autoload")
  folder = "autoload" if autoload else "ondemand"

  return os.path.join(".opencode", "rules", folder, f"{rule_id}.md")


def update_one(module_id, entry):
  if not isinstance(entry, dict):
    return False

  installed_version = entry.get("moduleVersion")
  if not installed_version:
    raise ValueError(f"moduleVersion missing for module {module_id}")

  files = entry.get("files")
  if not isinstance(files, list) or not files:
    raise ValueError(f"files missing/empty for module {module_id}")

  kit_file = module_meta_path(module_id)
  kit_version = read_frontmatter_version(kit_file)
  if kit_version == "":
    raise ValueError(f"kit module is missing version frontmatter: {kit_file}")

  kit_tuple = parse_semver(kit_version, context=kit_file)
  installed_tuple = parse_semver(installed_version, context=f"manifest module {module_id}")

  should_update = kit_tuple > installed_tuple

  changed = False
  if should_update:
    for file_entry in files:
      if not isinstance(file_entry, dict):
        raise ValueError(f"invalid file entry for module {module_id}: {file_entry}")

      src_rel = safe_src_path(file_entry.get("src") or "")
      old_dst_rel = safe_dst_path(file_entry.get("dst") or "")

      src = os.path.join(kit_root, src_rel)
      if not os.path.exists(src):
        raise ValueError(f"kit source missing: {src}")

      new_dst_rel = old_dst_rel
      if is_rule_src(src_rel):
        new_dst_rel = safe_dst_path(desired_dst_for_rule_src(src_rel))

      if new_dst_rel != old_dst_rel and os.path.exists(new_dst_rel):
        raise ValueError(f"destination already exists: {new_dst_rel} (moving from {old_dst_rel})")

      os.makedirs(os.path.dirname(new_dst_rel), exist_ok=True)
      shutil.copyfile(src, new_dst_rel)

      if new_dst_rel != old_dst_rel:
        if os.path.exists(old_dst_rel):
          os.remove(old_dst_rel)
        file_entry["dst"] = new_dst_rel

    entry["installedAt"] = today
    entry["moduleVersion"] = kit_version
    changed = True
    print(f"updated module {module_id}: {installed_version} -> {kit_version}")
  else:
    print(f"up-to-date module {module_id}: {installed_version}")

  return changed


manifest = load_manifest()
if manifest.get("version") != 2:
  raise SystemExit("unsupported manifest version (expected 2). Delete .opencode-kit.json and reinstall.")

installed = manifest.get("installed", {})
modules = installed.get("module", {})
if not isinstance(modules, dict):
  raise SystemExit("installed.module must be an object")

modified = False
for module_id, entry in modules.items():
  modified = update_one(module_id, entry) or modified

if modified:
  dump_manifest(manifest)
PY
}

usage() {
  cat <<'HELP'
Usage:
  opencode-kit list modules
  opencode-kit init
  opencode-kit add-module <group>/<module>
  opencode-kit update

Policy:
- Copy only (portable)
- Refuse overwrite: if destination exists, error (except: update overwrites manifest-tracked files)
- Does not edit target AGENTS.md; only 'init' updates opencode.json
- Writes manifest: .opencode-kit.json (version 2)

Module layout (kit):
- modules/<group>/<module>/MODULE.md
- modules/<group>/<module>/agents/<doc>.md
- modules/<group>/<module>/skills/<skill-id>/SKILL.md
- modules/<group>/<module>/rules/<doc>.md

Install destinations (target repo):
- Agents -> .opencode/agent/<group>-<module>-<doc>.md
- Skills -> .opencode/skill/<skill-id>/SKILL.md
- Rules  -> .opencode/rules/autoload/<group>-<module>-<doc>.md (if rule has frontmatter: autoload: true)
- Rules  -> .opencode/rules/ondemand/<group>-<module>-<doc>.md (default)

Naming:
- <group>, <module>, <doc>, <skill-id> must be kebab-case: ^[a-z0-9]+(-[a-z0-9]+)*$
HELP
}

main() {
  local root
  root="$(project_root)"
  cd "$root"

  local cmd="${1:-}"
  case "$cmd" in
    list)
      cmd_list "${2:-}"
      ;;
    init)
      cmd_init
      ;;
    add-module)
      add_module "${2:-}"
      ;;
    update)
      cmd_update
      ;;
    -h|--help|help|"")
      usage
      ;;
    *)
      die "unknown command: $cmd (run: opencode-kit --help)"
      ;;
  esac
}

main "$@"
